// First, add these dependencies to your app/build.gradle.kts (or build.gradle):
// implementation("androidx.camera:camera-core:1.4.0")
// implementation("androidx.camera:camera-camera2:1.4.0")
// implementation("androidx.camera:camera-lifecycle:1.4.0")
// implementation("androidx.camera:camera-view:1.3.1")
// implementation("androidx.lifecycle:lifecycle-runtime-ktx:2.8.7") // For viewModelScope if using ViewModel

// Also, ensure your AndroidManifest.xml has:
// <uses-permission android:name="android.permission.CAMERA" />
// <uses-feature android:name="android.hardware.camera" android:required="false" />
// For storage on older Androids: <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" android:maxSdkVersion="28" />
// (Since API 29+, no need for app-specific external storage)

// Note: CameraX versions as of October 2025; check developer.android.com for updates.
// This works on Android 5.0+ (API 21+), including hypothetical Android 16, as CameraX abstracts hardware differences.
// For Android 16, no major camera changes announced yet; standard setup applies.

import android.Manifest
import android.content.Context
import android.content.pm.PackageManager
import android.graphics.BitmapFactory
import android.graphics.Matrix
import android.os.Bundle
import android.os.Environment
import android.util.Log
import android.util.Size
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.Button
import android.widget.ImageView
import android.widget.Toast
import androidx.activity.result.contract.ActivityResultContracts
import androidx.appcompat.app.AppCompatActivity
import androidx.camera.core.Camera
import androidx.camera.core.CameraSelector
import androidx.camera.core.ImageCapture
import androidx.camera.core.ImageCaptureException
import androidx.camera.core.Preview
import androidx.camera.lifecycle.ProcessCameraProvider
import androidx.camera.view.PreviewView
import androidx.core.content.ContextCompat
import androidx.fragment.app.Fragment
import androidx.lifecycle.LifecycleOwner
import java.io.File
import java.io.FileOutputStream
import java.text.SimpleDateFormat
import java.util.Date
import java.util.Locale
import java.util.concurrent.ExecutorService
import java.util.concurrent.Executors

/**
 * A complete CameraX integration example in a Fragment.
 * Features:
 * - Camera preview using PreviewView.
 * - Capture button to take photo and save to app's external files directory (PICTURES folder).
 * - List and display saved images in a simple RecyclerView or via a button to open a gallery intent.
 * - Handles permissions via the provided PermissionManager.
 * - Rotates image if needed based on device orientation (basic handling).
 * - Compatible with Android 5.0+ to Android 16+; uses scoped storage (no WRITE_EXTERNAL_STORAGE needed on API 29+).
 *
 * Usage: Add this Fragment to your Activity, e.g., in MainActivity:
 * supportFragmentManager.beginTransaction().replace(R.id.container, CameraFragment()).commit()
 *
 * Layout (res/layout/fragment_camera.xml):
 * <?xml version="1.0" encoding="utf-8"?>
 * <LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
 *     android:layout_width="match_parent"
 *     android:layout_height="match_parent"
 *     android:orientation="vertical">
 *
 *     <androidx.camera.view.PreviewView
 *         android:id="@+id/previewView"
 *         android:layout_width="match_parent"
 *         android:layout_height="0dp"
 *         android:layout_weight="1" />
 *
 *     <Button
 *         android:id="@+id/btnCapture"
 *         android:layout_width="match_parent"
 *         android:layout_height="wrap_content"
 *         android:text="Capture Photo" />
 *
 *     <Button
 *         android:id="@+id/btnViewSaved"
 *         android:layout_width="match_parent"
 *         android:layout_height="wrap_content"
 *         android:text="View Saved Photos" />
 *
 * </LinearLayout>
 */
class CameraFragment : Fragment(), LifecycleOwner {

    private lateinit var previewView: PreviewView
    private lateinit var btnCapture: Button
    private lateinit var btnViewSaved: Button
    private lateinit var imageCapture: ImageCapture
    private lateinit var cameraExecutor: ExecutorService
    private lateinit var permissionManager: PermissionManager // From previous code

    // Directory for saving photos (app-specific external storage)
    private lateinit var photoDirectory: File

    override fun onCreateView(
        inflater: LayoutInflater,
        container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View? {
        val view = inflater.inflate(R.layout.fragment_camera, container, false)
        previewView = view.findViewById(R.id.previewView)
        btnCapture = view.findViewById(R.id.btnCapture)
        btnViewSaved = view.findViewById(R.id.btnViewSaved)

        // Initialize PermissionManager (pass activity from requireActivity())
        permissionManager = PermissionManager(requireActivity() as AppCompatActivity)

        // Initialize directory: App's external files dir under PICTURES
        photoDirectory = File(
            requireContext().getExternalFilesDir(Environment.DIRECTORY_PICTURES),
            "CameraXPhotos"
        )
        if (!photoDirectory.exists()) {
            photoDirectory.mkdirs()
        }

        cameraExecutor = Executors.newSingleThreadExecutor()

        // Request permissions before starting camera
        requestPermissionsAndStartCamera()

        // Capture button
        btnCapture.setOnClickListener { takePhoto() }

        // View saved button: For simplicity, logs paths and shows a toast; extend to RecyclerView or Intent
        btnViewSaved.setOnClickListener { viewSavedPhotos() }

        return view
    }

    private fun requestPermissionsAndStartCamera() {
        permissionManager.requestAllPermissions { granted, denied ->
            if (Manifest.permission.CAMERA in granted) {
                startCamera()
            } else {
                Toast.makeText(requireContext(), "Camera permission denied", Toast.LENGTH_SHORT).show()
            }
            if (Manifest.permission.WRITE_EXTERNAL_STORAGE in denied && android.os.Build.VERSION.SDK_INT < 29) {
                Toast.makeText(requireContext(), "Storage permission needed for older Android", Toast.LENGTH_SHORT).show()
            }
        }
    }

    private fun startCamera() {
        val cameraProviderFuture = ProcessCameraProvider.getInstance(requireContext())

        cameraProviderFuture.addListener({
            val cameraProvider: ProcessCameraProvider = cameraProviderFuture.get()

            // Preview
            val preview = Preview.Builder()
                .build()
                .also {
                    it.setSurfaceProvider(previewView.surfaceProvider)
                }

            // ImageCapture
            imageCapture = ImageCapture.Builder()
                .build()

            // Select back camera as default
            val cameraSelector = CameraSelector.DEFAULT_BACK_CAMERA

            try {
                // Unbind use cases before rebinding
                cameraProvider.unbindAll()

                // Bind use cases to lifecycle
                val camera = cameraProvider.bindToLifecycle(
                    this, cameraSelector, preview, imageCapture
                )

            } catch (exc: Exception) {
                Log.e(TAG, "Use case binding failed", exc)
            }

        }, ContextCompat.getMainExecutor(requireContext()))
    }

    private fun takePhoto() {
        val outputFile = File(
            photoDirectory,
            SimpleDateFormat("yyyy-MM-dd-HH-mm-ss-SSS", Locale.US).format(Date()) + ".jpg"
        )

        val outputOptions = ImageCapture.OutputFileOptions.Builder(outputFile).build()

        imageCapture.takePicture(
            outputOptions,
            ContextCompat.getMainExecutor(requireContext()),
            object : ImageCapture.OnImageSavedCallback {
                override fun onError(exc: ImageCaptureException) {
                    Log.e(TAG, "Photo capture failed: ${exc.message}", exc)
                    Toast.makeText(requireContext(), "Photo capture failed", Toast.LENGTH_SHORT).show()
                }

                override fun onImageSaved(output: ImageCapture.OutputFileResults) {
                    val savedUri = output.savedUri ?: return
                    Log.d(TAG, "Photo saved to: $savedUri")

                    // Optional: Rotate image if needed (basic EXIF-based rotation)
                    rotateImageIfNeeded(outputFile)

                    Toast.makeText(requireContext(), "Photo saved: ${outputFile.absolutePath}", Toast.LENGTH_SHORT).show()
                }
            }
        )
    }

    // Basic image rotation based on EXIF (for portrait/landscape)
    private fun rotateImageIfNeeded(file: File) {
        val bitmap = BitmapFactory.decodeFile(file.absolutePath) ?: return
        val matrix = Matrix()
        // Simple rotation: 90 degrees if height > width (portrait mode)
        if (bitmap.height > bitmap.width) {
            matrix.postRotate(90f)
        }
        val rotatedBitmap = BitmapFactory.decodeFile(file.absolutePath)?.let {
            BitmapFactory.decodeFile(file.absolutePath)?.copy(Bitmap.Config.ARGB_8888, true)?.let { mutable ->
                mutable.let { mutableBitmap ->
                    val canvas = android.graphics.Canvas(mutableBitmap)
                    canvas.drawBitmap(it, matrix, null)
                    val outputStream = FileOutputStream(file)
                    mutableBitmap.compress(Bitmap.CompressFormat.JPEG, 100, outputStream)
                    outputStream.flush()
                    outputStream.close()
                }
            }
        }
    }

    private fun viewSavedPhotos() {
        val savedFiles = photoDirectory.listFiles { _, name -> name.endsWith(".jpg") } ?: emptyArray()
        if (savedFiles.isEmpty()) {
            Toast.makeText(requireContext(), "No photos saved yet", Toast.LENGTH_SHORT).show()
            return
        }

        // For demo: Show first image in an ImageView (add ImageView to layout if needed)
        // Or launch gallery intent:
        val intent = android.content.Intent(Intent.ACTION_VIEW).apply {
            setDataAndType(photoDirectory.toUri(), "image/*")
            addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION)
        }
        try {
            startActivity(intent)
        } catch (e: Exception) {
            // Fallback: Log all paths
            savedFiles.forEach { Log.d(TAG, "Saved photo: ${it.absolutePath}") }
            Toast.makeText(requireContext(), "Photos in: ${photoDirectory.absolutePath}", Toast.LENGTH_LONG).show()
        }
    }

    override fun onDestroy() {
        super.onDestroy()
        cameraExecutor.shutdown()
    }

    companion object {
        private const val TAG = "CameraFragment"
    }
}

// Extension for Uri (if needed for intent)
private fun File.toUri(): android.net.Uri = android.net.Uri.fromFile(this)

// In your MainActivity:
class MainActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main) // With <FrameLayout id="container" ... />
        if (savedInstanceState == null) {
            supportFragmentManager.beginTransaction()
                .replace(R.id.container, CameraFragment())
                .commitNow()
        }
    }
}









// Updated Dependencies (as of October 14, 2025):
// For CameraX: Latest stable version is 1.5.1 across all artifacts.
// implementation("androidx.camera:camera-core:1.5.1")
// implementation("androidx.camera:camera-camera2:1.5.1")
// implementation("androidx.camera:camera-lifecycle:1.5.1")
// implementation("androidx.camera:camera-view:1.5.1")
// For Lifecycle (optional, but used for potential ViewModel integration):
// implementation("androidx.lifecycle:lifecycle-runtime-ktx:2.9.4")

// Note: These versions support Android API 23+ (minSdk updated in CameraX 1.5.0). 
// Compatible with Android 15 features; Android 16 compatibility is expected as no major breaking changes announced.
// Ensure your app's minSdk is at least 21 for broader support, but CameraX requires 23+ for latest.

// The rest of the code remains the same as previously provided, with no changes needed for these versions.

